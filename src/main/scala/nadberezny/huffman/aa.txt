package nadberezny.huffman


object GetLabeledTree {
  type Tree = Map[Int, Set[Int]]
  type Edge = Set[String]

  def apply(root: Node) = {
    def traverse(list: List[(Node, String, Boolean)], edges: Set[Edge]): Set[Edge] = {
      list match {
        case (Node(_, _, outgoingNodesOption), parentLabel, isLeft) :: nodesLeft =>
          val label = (if (isLeft) parentLabel.toByte + 1 else parentLabel.toByte + 2).toBinaryString
          val nodes = outgoingNodesOption match {
            case None => nodesLeft
            case Some(outgoingNodes) =>
              (outgoingNodes._1, label, true) :: (outgoingNodes._2, label, false) :: nodesLeft
          }
          traverse(nodes, edges + Set(parentLabel, label))

        case Nil => edges
      }
    }

    val nodeLeft = (root.nodes.get._1, "0", true)
    val nodeRight = (root.nodes.get._2, "0", false)
    traverse(List(nodeLeft, nodeRight), Set.empty)
  }
}
